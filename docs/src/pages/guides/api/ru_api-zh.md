# Подход API

<p class="description">Мы много узнали о том, как используется Material-UI, а переработка v1 позволила нам полностью переосмыслить API-интерфейс компонента.</p>

> Дизайн API затруднен, потому что вы можете сделать его простым, но на самом деле обманчиво сложным или сделать его простым, но, похоже, сложным.

[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)

Как заметил Себастьян Маркбадж [,](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html)абстракция превосходит неправильные абстракции. Мы предоставляем низкоуровневые компоненты, чтобы максимально использовать возможности композиций.

## Состав

Возможно, вы заметили некоторую несогласованность API в отношении компоновки компонентов. Чтобы обеспечить определенную прозрачность, при разработке API мы использовали следующие правила:

1. Использование свойства `children` - это идиоматический способ сделать композицию с помощью React.
2. Иногда нам нужен только ограниченный состав ребенка, например, когда нам не нужно разрешать перестановки дочерних заказов. В этом случае предоставление явных свойств делает реализацию более простой и результативной; например, `Tab` принимает `значка` и свойство `метки`.
3. Консистенция API.

## правила

Помимо вышеуказанного компромисса, мы применяем следующие правила:

### распространение

Предоставленные недокументированные свойства распространяются на корневой элемент; например, свойство `className` применяется к корню.

Теперь, допустим, вы хотите отключить рябь в `MenuItem`. Вы можете воспользоваться распространенным поведением:

```jsx
<MenuItem disableRipple />
```

Свойство `disableRipple` будет проходить следующим образом: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).

### Родные свойства

Мы не документируем собственные свойства, поддерживаемые DOM, как [`className`](/customization/overrides/#overriding-with-class-names).

### Классы CSS

Все компоненты принимают свойство [`классов`](/customization/overrides/#overriding-with-classes) для настройки стилей. Дизайн классов отвечает двум ограничениям: сделать структуру классов максимально простой и достаточной для реализации спецификации Material Design.

- Класс, применяемый к корневому элементу, всегда называется `root`.
- Все стили по умолчанию сгруппированы в один класс.
- Классы, применяемые к элементам, отличным от root, имеют префикс имени элемента, например `paperWidthXs` в компоненте Dialog.
- Варианты , применяемые Логическое свойство **не** префикс, например, `закругленных` класса применяемого `закругленных` свойства.
- Варианты, применяемые свойством enum **являются** префиксными, например, `colorPrimary` класс, применяемый свойством `color = "primary"`.
- Вариант имеет **один уровень специфичности**. `цвет` и `вариант` свойства рассматриваются вариант. Чем ниже специфичность стиля, тем проще переопределить его.
- Мы увеличиваем специфика для модификатора варианта. Мы уже **должны сделать это** для псевдо-классов (`: парить`, `: фокус`и т.д.). Это позволяет гораздо больший контроль за счет большего количества шаблонов. Надеюсь, это также более интуитивно понятно.

```js
const styles = {
  root: {
    color: green[600],
    '&$checked': {
      color: green[500],
    },
  },
  checked: {},
};
```

### Вложенные компоненты

Вложенные компоненты внутри компонента имеют:

- их собственные сплющенные свойства, если они являются ключевыми для абстракции компонента верхнего уровня, например, и `id` для компонента `Input`.
- их собственное свойство `xxxProps` когда пользователям может понадобиться настроить подкомпоненты внутреннего рендеринга, например, подвергая `свойствам входных данных` и `InputProps` компонентам, которые используют `Input` внутренне.
- их собственное свойство `xxxComponent` для выполнения инъекции компонентов.
- их собственное свойство `xxxRef` когда пользователю может потребоваться выполнение императивных действий, например, выставляя свойство `inputRef` для доступа к вводу `входа` на компоненте `Input`. Это помогает ответить на вопрос [«Как я могу получить доступ к элементу DOM?»](/getting-started/faq/#how-can-i-access-the-dom-element-)

### Именование собственности

Имя логического свойства должно быть выбрано на основе значения **умолчанию**. Например, атрибут `отключен` на входном элементе, если он указан, по умолчанию равен `true`. Этот выбор допускает сокращенное обозначение:

```diff
-<Input enabled={false} />
+<Input disabled />
```

### Контролируемые компоненты

Большая часть контролируемого компонента управляются через `значение` и `OnChange` свойств, однако, `открыт` / `OnClose` / `OnOpen` комбинация используется для состояния , связанных с дисплеем.

### boolean vs enum

Существует два варианта разработки API для вариантов компонента: с *булевым*; или с *перечислением*. Например, давайте возьмем кнопку с разными типами. У каждого варианта есть свои плюсы и минусы:

- Вариант 1 *boolean*:
    
    ```tsx
    type Props = {
    содержит: boolean;
    fab: boolean;
    };
    ```
    
    Этот API включил сокращенную нотацию: `<Button>`, `<Button contained />`, `<Button fab />`.

- Вариант 2 *перечисление*:
    
    ```tsx
    type Props = {
    вариант: 'текст' | 'contains' | «ВСБ»;
    }
    ```
    
    Этот API более подробный: `<Button>`, `<Button variant="contained">`, `<Button variant="fab">`.
    
    Однако это предотвращает использование недопустимой комбинации, ограничивает количество выставленных свойств и может легко поддерживать новые значения в будущем.

Компоненты Material-UI используют комбинацию двух подходов в соответствии со следующими правилами:

- A *boolean* используется, когда требуется **2** степени свободы.
- *enum* используется, когда требуется **> 2** степени свободы, или если есть вероятность, что в будущем могут потребоваться дополнительные степени свободы.

Возврат к предыдущему примеру; так как он требует 3 степеней свободы, мы используем *перечисление*.